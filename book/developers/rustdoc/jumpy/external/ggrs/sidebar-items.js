window.SIDEBAR_ITEMS = {"constant":[["NULL_FRAME","Internally, -1 represents no frame / invalid frame."]],"enum":[["DesyncDetection","Desync detection by comparing checksums between peers."],["GGRSError","This enum contains all error messages this library can return. Most API functions will generally return a `Result<(),GGRSError>`."],["GGRSEvent","Notifications that you can receive from the session. Handling them is up to the user."],["GGRSRequest","Requests that you can receive from the session. Handling them is mandatory."],["InputStatus","[`InputStatus`] will always be given together with player inputs when requested to advance the frame."],["PlayerType","Defines the three types of players that GGRS considers:"],["SessionState","A session is always in one of these states. You can query the current state of a session via `current_state`."]],"struct":[["GameStateCell","An [`Arc<Mutex>`] that you can `save()`/`load()` a `T` to/from. These will be handed to the user as part of a [`GGRSRequest`]."],["Message","A messages that `NonBlockingSocket` sends and receives. When implementing `NonBlockingSocket`, you should deserialize received messages into this `Message` type and pass them."],["NetworkStats","The `NetworkStats` struct contains statistics about the current session."],["P2PSession","A [`P2PSession`] provides all functionality to connect to remote clients in a peer-to-peer fashion, exchange inputs and handle the gamestate by saving, loading and advancing."],["SessionBuilder","The [`SessionBuilder`] builds all GGRS Sessions. After setting all appropriate values, use `SessionBuilder::start_yxz_session(...)` to consume the builder and create a Session of desired type."],["SpectatorSession","[`SpectatorSession`] provides all functionality to connect to a remote host in a peer-to-peer fashion. The host will broadcast all confirmed inputs to this session. This session can be used to spectate a session without contributing to the game input."],["SyncTestSession","During a [`SyncTestSession`], GGRS will simulate a rollback every frame and resimulate the last n states, where n is the given check distance. The resimulated checksums will be compared with the original checksums and report if there was a mismatch."],["UdpNonBlockingSocket","A simple non-blocking UDP socket tu use with GGRS Sessions. Listens to 0.0.0.0 on a given port."]],"trait":[["Config","Compile time parameterization for sessions."],["NonBlockingSocket","This [`NonBlockingSocket`] trait is used when you want to use GGRS with your own socket. However you wish to send and receive messages, it should be implemented through these two methods. Messages should be sent in an UDP-like fashion, unordered and unreliable. GGRS has an internal protocol on top of this to make sure all important information is sent and received."]],"type":[["Frame","A frame is a single step of execution."],["PlayerHandle","Each player is identified by a player handle."]]};